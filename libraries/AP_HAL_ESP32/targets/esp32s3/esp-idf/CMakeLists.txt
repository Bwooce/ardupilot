cmake_minimum_required(VERSION 3.16)

set(CMAKE_TOOLCHAIN_FILE $ENV{IDF_PATH}/tools/cmake/toolchain-esp32s3.cmake CACHE STRING "")

project(ardupilot)

# Include for ESP-IDF build system functions
include($ENV{IDF_PATH}/tools/cmake/idf.cmake)

# treat sdkconfig as build product generated by the defaults
set(SDKCONFIG_DEFAULTS_LIST "${CMAKE_CURRENT_LIST_DIR}/sdkconfig.defaults")
if(EXISTS "${SDKCONFIG_BOARD}")
    message("Using board-specific config: ${SDKCONFIG_BOARD}")
    list(APPEND SDKCONFIG_DEFAULTS_LIST "${SDKCONFIG_BOARD}")
endif()

# Base components (all IDF versions)
set(AP_COMPONENTS
    freertos fatfs spiffs nvs_flash esptool_py app_update esp_adc
    driver  # Monolithic in IDF 5.4, shim in 5.5+
    lwip esp_wifi esp_netif esp_system esp_rom esp_timer esp_psram espcoredump
    efuse
)

# IDF 5.5+ split driver into individual esp_driver_* components
foreach(drv gpio i2c spi uart rmt mcpwm twai usb_serial_jtag sdmmc sdspi)
    if(EXISTS "$ENV{IDF_PATH}/components/esp_driver_${drv}")
        list(APPEND AP_COMPONENTS esp_driver_${drv})
    endif()
endforeach()

# IDF 6.0 split HAL into separate components
if(EXISTS "$ENV{IDF_PATH}/components/esp_hal_wdt")
    list(APPEND AP_COMPONENTS esp_hal_wdt)
endif()

# esp-dsp for FFT/DSP support via IDF component manager.
#
# ArduPilot uses idf.cmake directly (not project.cmake), so we must enable
# the component manager explicitly. The component manager only resolves
# dependencies from components that have BOTH CMakeLists.txt AND
# idf_component.yml -- the ap_deps/ component serves as this trigger.
#
# idf.cmake defaults IDF_COMPONENT_MANAGER to 0; we set it to 1.
# The component manager's Python code also requires IDF_TARGET as an
# environment variable (normally set by idf.py; we must set it explicitly).
set(AP_DEPS_DIR "${CMAKE_SOURCE_DIR}/ap_deps")
if(EXISTS "${AP_DEPS_DIR}/idf_component.yml")
    set(ENV{IDF_TARGET} esp32s3)
    idf_build_set_property(IDF_COMPONENT_MANAGER 1)
    idf_build_set_property(__COMPONENT_MANAGER_INTERFACE_VERSION 4)
    idf_build_component(${AP_DEPS_DIR})
    list(APPEND AP_COMPONENTS ap_deps)
    message(STATUS "IDF component manager enabled (ap_deps trigger component)")
endif()

# Create idf::esp32 and idf::freertos static libraries
idf_build_process(esp32s3
    COMPONENTS ${AP_COMPONENTS}
    SDKCONFIG ${CMAKE_BINARY_DIR}/sdkconfig
    SDKCONFIG_DEFAULTS "${SDKCONFIG_DEFAULTS_LIST}"
    BUILD_DIR ${CMAKE_BINARY_DIR}
)

# Detect IDF version for conditional compilation
idf_build_get_property(idf_ver IDF_VER)
message(STATUS "Building with ESP-IDF ${idf_ver}")

set(elf_file ardupilot.elf)

add_executable(${elf_file} main.c)

if(NOT DEFINED ARDUPILOT_CMD)
    set(ARDUPILOT_CMD "none")
endif()

message("WAF_BUILD_TARGET=${WAF_BUILD_TARGET}")

string(REGEX MATCH "^(examples|tool)/" IS_EXAMPLE "${WAF_BUILD_TARGET}")

if (IS_EXAMPLE)
    string(REPLACE "/" ";" A ${WAF_BUILD_TARGET})
    list(GET A 0 EXAMPLE_BASE)
    list(GET A 1 EXAMPLE_NAME)
    message("Building ${EXAMPLE_BASE} ${EXAMPLE_NAME}")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/${EXAMPLE_BASE}/lib${EXAMPLE_NAME}.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libap.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "plane")
    message("Building for plane")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libarduplane.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduPlane_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "copter")
    message("Building for copter")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libarducopter.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduCopter_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "rover")
    message("Building for rover")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libardurover.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libRover_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "sub")
    message("Building for submarine")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libardusub.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduSub_libs.a")
ENDIF()

add_custom_target(showinc ALL
        COMMAND echo
        "$<TARGET_PROPERTY:${elf_file},INCLUDE_DIRECTORIES>"
        > includes.list
    VERBATIM
    BYPRODUCTS includes.list
    COMMAND_EXPAND_LISTS
)

# Link the static libraries to the executable
target_include_directories(${elf_file} PRIVATE ${CMAKE_SOURCE_DIR}/../../../../modules/DroneCAN/libcanard)

set(AP_LINK_LIBS
    idf::freertos idf::fatfs idf::spiffs idf::nvs_flash idf::spi_flash
    idf::app_update idf::esp_adc
    idf::driver idf::lwip idf::esp_wifi idf::esp_netif idf::esp_system idf::esp_rom
    idf::esp_timer idf::esp_psram idf::espcoredump idf::efuse
)

# IDF 5.5+ individual driver components (detected at configure time)
foreach(drv gpio i2c spi uart rmt mcpwm twai usb_serial_jtag sdmmc sdspi)
    if(TARGET idf::esp_driver_${drv})
        list(APPEND AP_LINK_LIBS idf::esp_driver_${drv})
    endif()
endforeach()

# IDF 6.0 split HAL components
if(TARGET idf::esp_hal_wdt)
    list(APPEND AP_LINK_LIBS idf::esp_hal_wdt)
endif()

# esp-dsp for FFT/DSP support
if(TARGET idf::espressif__esp-dsp)
    list(APPEND AP_LINK_LIBS idf::espressif__esp-dsp)
    # PicoLibC (IDF 6.0+) doesn't expose std::cos/std::sin/std::atan in <cmath>.
    # The esp-dsp kalman module uses these. Force-include math.h and add using
    # declarations so the std:: qualified names resolve to the global C versions.
    if(EXISTS "${CMAKE_SOURCE_DIR}/picolibc_cmath_shim.h")
        target_compile_options(__idf_espressif__esp-dsp PRIVATE
            "-include" "${CMAKE_SOURCE_DIR}/picolibc_cmath_shim.h")
    endif()
endif()

target_link_libraries(${elf_file} ${AP_LINK_LIBS})

# Attach additional targets to the executable file for flashing,
# linker script generation, partition_table generation, etc.
idf_build_executable(${elf_file})



# wrap malloc to ensure memory is zeroed
target_link_options(${elf_file} PRIVATE "-Wl,--wrap,malloc")

set(CMAKE_EXPORT_COMPILE_COMMANDS 1)

set(mapfile "${CMAKE_BINARY_DIR}/${CMAKE_PROJECT_NAME}.map")
# Add cross-reference table to the map file
target_link_options(${elf_file} PRIVATE "-Wl,--cref")
# Add this symbol as a hint for esp_idf_size to guess the target name
target_link_options(${elf_file} PRIVATE "-Wl,--defsym=IDF_TARGET_${idf_target}=0")
# Enable map file output
target_link_options(${elf_file} PRIVATE "-Wl,--Map=${mapfile}")
# Check if linker supports --no-warn-rwx-segments
execute_process(COMMAND ${CMAKE_LINKER} "--no-warn-rwx-segments" "--version"
    RESULT_VARIABLE result
    OUTPUT_QUIET
    ERROR_QUIET)
if(${result} EQUAL 0)
    # Do not print RWX segment warnings
    target_link_options(${elf_file} PRIVATE "-Wl,--no-warn-rwx-segments")
endif()
if(CONFIG_ESP_ORPHAN_SECTION_WARNING)
    # Print warnings if orphan sections are found
    target_link_options(${elf_file} PRIVATE "-Wl,--orphan-handling=warn")
endif()

idf_build_get_property(idf_path IDF_PATH)
idf_build_get_property(python PYTHON)

set(idf_size ${python} -m esp_idf_size)

# Add size targets, depend on map file, run esp_idf_size
add_custom_target(size
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)

add_custom_target(size-files
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "IDF_SIZE_MODE=--files"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)

add_custom_target(size-components
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "IDF_SIZE_MODE=--archives"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)
